# 운영체제 연습 문제
### 운영체제 개요 ~ CPU 스케줄링  

> Q. 운영체제란?  
> A. 컴퓨터 사용자와 하드웨어 사이의 중재자 역할을 하는 프로그램이다. 사용자에게 편리한 인터페이스 환경을 제공하고 컴퓨터 시스템 자원을 효율적으로 관리한다.

> Q. 커널이란?  
> A. 운영체제의 핵심적인 기능을 모아 놓은 것.

> Q. 운영체제의 역할은?  
> A. 자원관리, 자원보호, 하드웨어 인터페이스 제공, 사용자 인터페이스 제공.

> Q. 운영체제의 목적은?  
> A. 시스템 성능 / 생산성 향상  
> ① 처리능력 향상 ② 신뢰도 향상 ③ 응답시간 단축 ④ 사용 가능도 향상.

> Q. 초기 운영체제의 문제점은?  
> A. ① 작업 준비 시간(Job SetUp Time)  ② 작업 철거 시간(TearDown Time) ③ 작업 변환 시간(Job Transition Time).

> Q. 단순 일괄처리 시스템의 목적은?  
> A. 작업 전환 시간을 줄이고, CPU의 이용도를 높이는 것.

> Q. 자동적 작업 순서화의 장점과 상주 모니터가 무엇인지 작성하시오.  
> A. 장점 : 다음에 처리할 작업들의 순서를 자동함으로써 작업 준비 시간 등을 줄일 수 있다.  
> 상주 모니터 : 하나의 작업에서 다른 작업으로 실행할 수 있도록 자동적으로 제어해주는 프로그램.

> Q. 스풀링이란?  
> A. 하나의 작업이 CPU를 사용하는 동안에 다른 작업은 I/O를 수행하여 메모리에 적재하는 것.

> Q. 작업풀이란?  
> A. 시스템이나 응용 프로그램이 처리해야 할 작업들을 저장하고 관리하는 메모리 내의 자료구조.

> Q. 멀티 프로그래밍의 정의는?  
> A. 한 개 이상의 사용자 프로그램(작업)이 메모리에 존재/적재 되어 있는 것.

> Q. 멀티 프로그래밍의 문제점은?  
> A. 프로그램 내부에서 I/O가 발생하면 CPU idle(쉬는 시간)이 발생한다.

> Q. 멀티 프로세싱과 멀티 프로세서의 차이는?  
> A. 멀티 프로세싱은 하나 이상의 프로세스를 실행하는 기능(소프트웨어적 개념), 멀티 프로세서는 하나의 보드에 여러 개의 CPU 칩이 존재하는 하드웨어 시스템(하드웨어적 개념).

> Q. 멀티 프로세싱의 문제점은?  
> A. 프로그램 1이 무한루프를 실행하여 CPU를 점유하면 다른 프로그램은 CPU를 사용할 수 없음.

> Q. 배치 처리시스템의 문제점은?  
> A. ① 작업들 사이에 대화적이지 않다.  ② 응답 시간이 길다.  ③ 다수의 사용자가 컴퓨터 자원을 공유하기 때문에 작업 우선순위와 자원 분배에 관한 복잡성을 증가시킬 수 있다.

> Q. 멀티 프로그래밍의 정도란?  
> A. 메모리에 적재되어 실행 대기 중인 프로세스의 수.

> Q. 잡 스케줄러의 역할은?  
> A. 멀티 프로그래밍의 정도를 결정하고, 스풀러에 의해 디스크에 저장된 작업을 선정한다.

> Q. 시분할 시스템이란?  
> A. 한 작업이 CPU를 사용할 수 있는 최대의 시간(Time Quantum)을 정하고 이 시간 동안만 CPU를 사용하게 하고 시간이 지나면 다른 작업이 CPU를 사용하게 한다. (멀티프로세싱 + 타임 퀀텀 == 시분할 시스템).

> Q. 시분할 운영체제의 문제점은?  
> A.  
> 1. 메모리 관리 및 메모리 보호 정책이 복잡해진다.
> 2. 사용자들의 프로그램이 병행/동시 수행할 수 있는 방법들이 필요하다.
> 3. cpu스케줄링 방식들이 더 어렵고 복잡해진다.
> 4. 작업들 사이에 동기화 / 통신 등의 문제를 해결해야한다.

> Q. 큐를 세우는 이유는?  
> A. 공용 자원을 사용하기 위해서.

> Q. 서스펜드란?  
> A. 메모리 부족 또는 입출력 대기 등 사용자 요청에 의해 중요한 작업 자원을 재할당하기 위해 일시적으로 프로세스를 중지 시키는 것.

> Q. PCB란?  
> A. PCB란 프로세스 제어 블록의 약자로, 프로세스를 실행하는데 필요한 중요한 정보를 보관하는 자료구조.

> Q. PCB의 구성  
> A. 프로세스 구분자(PID), 포인터, 프로세스 상태, 프로그램 카운터, 레지스터 정보, 메모리 관리 정보, 계정 정보, 프로세스 우선순위, 할당된 자원 정보, 부모 및 자식 프로세스 구분자.

> Q. 문맥 교환 (Context Switching) 이란?  
> A. CPU를 차지하던 프로세스가 나가고 새로운 프로세스를 받아들이는 작업.

> Q. 디스패치란?  
> A. CPU 스케줄러가 준비 상태에 있는 프로세스 중 하나를 골라 CPU를 할당하는 작업.

> Q. fork() 시스템 호출에 대해서 설명하시오.  
> A. fork() 시스템 호출은 실행 중인 프로세스를 복사하는 함수이다. 이때 실항하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스로서 부모-자식 관계가 된다.

> Q. 인터럽트와 폴링의 차이는?  
> A. 인터럽트는 이벤트 발생 시 CPU가 자동으로 반응하여 해당 이벤트를 처리하는 방식이고, 폴링은 CPU가 주기적으로 장치 상태를 확인하는 방식이다.

> Q. ISR이란?  
> A. ISR(Interrupt Service Routine)은 특정 인터럽트가 발생했을 때 실행되는 처리 루틴으로, 인터럽트를 신속하게 처리하고 시스템을 원래 상태로 복귀시키는 함수다.

> Q. 인터럽트 벡터란?  
> A. 인터럽트 벡터는 인터럽트 식별 번호(ID)와 그 인터럽트를 처리하는 ISR(Interrupt Service Routine)의 주소를 연결하는 테이블이다. 시스템은 인터럽트 발생 시 이 테이블을 참조하여 해당 ISR을 찾고 실행한다.

> Q. 프로그램이 프로세스가 되려면 운영체제로부터 무엇을 받아야 하는가?  
> A. 프로세스 제어 블록(PCB).

> Q. 프로세스의 상태 중 CPU를 할당받기 위해 기다리는 상태는 무엇인가?  
> A. 준비 상태.

> Q. 프로세스의 상태 중 입출력 작업을 하기 위해 이동하는 상태는 무엇인가?  
> A. 대기 상태.

> Q. 프로그램과 프로세스의 개념에 대해서 설명하시오.  
> A.  
> 프로그램 : 저장장치에 저장되어 있는 정적인 상태.  
> 프로세스 : 실행을 위해 메모리 위에 올라온 동적인 상태.

> Q. 프로세스의 정의  
> A. 현재 실행중이거나 곧 실행 가능한 PCB를 가진 프로그램.

> Q. CPU 스케줄러의 역할은?  
> A. 여러 프로세스의 상황을 고려하여 CPU와 시스템 자원의 배정을 결정.

> Q. CPU 스케줄러가 준비 상태에 있는 프로세스 중 하나를 골라 CPU를 할당하는 작업을 무엇이라고 하는가?  
> A. 디스패치.

> Q. 실행 상태에서 하나의 프로세스가 나가고 새로운 프로세스가 들어오는 상황을 무엇이라고 하는가?  
> A. 문맥 교환(Context Switching).

> Q. 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 시스템 호출은 무엇인가?  
> A. fork().

> Q. 프로세스의 골격은 그대로 둔 채 코드 영역만 바꾸는 시스템 호출은 무엇인가?  
> A. exec().

> Q. 프로세스의 상태 5가지와 타임아웃에 대해서 설명하시오.  
> A.  
> 생성 상태 : 프로세스가 메모리에 올라와 실행 준비를 완료한 상태, 이때 PCB 생성.  
> 준비 상태 : 프로세스가 CPU를 얻을 때까지 기다리는 상태.  
> 실행 상태 : 프로세스가 CPU를 얻어서 실제 작업을 수행하는 상태.  
> 대기 상태 : 프로세스가 필요한 자원을 기다리거나,  I/O를 수행하기 위해 일시적으로 프로세스를 중지한 상태.  
> 완료 상태 : 실행 상태의 프로세스가 주어진 시간 안에 작업을 마치면 진입하는 상태. 이때 PCB는 폐기됨.  
> 타임 아웃 : 프로세스가 주어진 타임 슬라이스 동안 작업을 완료하지 못하면 다시 준비 상태로 보내는 것.

> Q. 프로세스의 코드에 정의된 절차에 따라 CPU에 작업 요청을 하는 실행 단위로서 가벼운 프로세스라고 불리는 것은 무엇인가?  
> A. 스레드.

> Q. lpthread 란?  
> A. POSIX 라이브러리를 링크하여 멀티 스레딩을 지원한다. 어떤 파일 내에 멀티 스레딩 프로그래밍을 수행하기 위해 필요한 함수들을 사용할 수 있도록 한다.

> Q. 스레드의 장점에 대해서 설명하시오.  
> A.  
> 1. 문맥 교환 시간이 줄어든다  
> 2. 실행 단위가 스레드로 세분화 되어 병행 수행이 증가한다.
>3. 스레드 생성시간이 프로세스 생성시간에 비해 짧고 효율적이다.

> Q. 멀티 스레드의 장점에 대서 설명하시오.  
> A. 1. 응답성 향상  2. 효율성 향상  3. 자원공유  4. 다중 CPU 지원.

> Q. 작업이 끝난 프로세스의 자원을 회수하는 행위를 무엇이라고 하는가?  
> A. 자원 회수.

> Q. 시스템 내 전체 프로세스의 수를 조절하는 것으로, 장기 스케줄링 또는 작업 스케줄링이라 불리는 스케줄링 수준은 무엇인가?  
> A. 고수준 스케줄링.

> Q. 어떤 프로세스에 CPU를 할당하고 어떤 프로세스를 대기 상태로 보낼지 등을 결정하는 스케줄링 수준은 무엇인가?  
> A. 저수준 스케줄링.

> Q. 어떤 프로세스가 CPU를 할당받아 실행 중이더라도 운영체제가 CPU를 강제로 빼앗을 수 있는 스케줄링은 무엇인가?  
> A. 선점형 스케줄링.

> Q. 현재 입출력을 진행하는 프로세스로, 사용자와 상호작용이 가능하여 상호작용 프로세스라고도 불리는 것은 무엇인가?  
> A. 전면 프로세스.

> Q. 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?  
> A. FCFS 스케줄링.

> Q. 준비 큐에 있는 프로세스 중 실행시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 스케줄링 알고리즘은 무엇인가?  
> A. SJF 스케줄링.

> Q. SJF 스케줄링 알고리즘의 단점으로 크기가 큰 작업이 계속 뒤로 밀리는 현상을 무엇이라 하는가?  
> A. 아사 현상, 무한 대기 현상.

> Q. 아사 현상을 해결하는 방법을 설명하시오.  
> A. 에이징.

> Q. 서비스를 받기 위해 대기한 시간과 CPU 사용시간을 고려하여 우선순위를 정하는 스케줄링 알고리즘은 무엇인가?  
> A. HRN 스케줄링.

> Q. 프로세스가 할당받은 시간(타임 슬라이스) 동안 작업하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 다음 자기 차례가 올 때까지 기다리는 선점형 스케줄링 알고리즘 중 가장 단순한 것은 무엇인가?  
> A. 라운드 로빈 스케줄링.

> Q. 타임 슬라이스의 크기와 문맥 교환의 관계를 설명하시오.  
> A. 타임 슬라이스가 작으면 문맥 교환의 횟수가 늘어난다. 타임 슬라이스가 크면 문맥 교환의 횟수가 적어진다. 따라서 타임 슬라이스의 크기와 문맥 교환의 관계는 반비례 관계다.

> Q. 기본적으로 라운드 로빈 방식을 사용하지만, CPU를 할당받을 프로세스를 선택할 때 남아있는 작업 시간이 가장 적은 것을 선택하는 스케줄링 알고리즘은 무엇인가?  
> A. SRT 스케줄링.

> Q. 우선순위에 따라 준비 큐를 여러 개 사용하며 고정형 우선순위를 적용하는 스케줄링 알고리즘은 무엇인가?  
> A. 멀티 레벨(다단계) 큐 스케줄링.

> Q. 우선순위에 따라 준비 큐를 여러 개 사용하며 프로세스가 CPU를 사용한 후 우선순위가 낮아지는 특성을 가진 스케줄링 알고리즘은 무엇인가?  
> A. 멀티 레벨(다단계) 피드백 큐 스케줄링.

> Q. 멀티 피드백 큐 스케줄링에서 마지막 큐에 있는 프로세스(우선순위가 가장 낮은 프로세스)의 타임 슬라이스 크기는 얼마인가?  
> A. 무한대.

> Q. 다단계 피드백 큐 스케줄링에서 우선순위가 낮아질수록 타임 슬라이스의 크기는 어떻게 변하는가?  
> A. 커진다.

> Q. 다단계 피드백 큐 스케줄링에서 마지막 큐(우선순위가 가장 낮은 큐)는 어떤 스케줄링 알고리즘처럼 동작하는가?  
> A. FCFS 스케줄링.

> Q. CPU 스케줄링의 단계와 그 특징을 설명하시오.  
> A.  
> 고수준 스케줄링(job or long-term scheduler)  - 시스템 내 전체 작업 수를 조절한다   
> 중간수준 스케줄링(medium-term or swapper) - 전체 시스템의 활성화된 프로세스 수를 조절하여 과부하를 막는다  
> 저수준 스케줄링(short-term or cpu scheduler) - 어떤 프로세스에 cpu를 할당할 지, 어떤 프로세스를 대기 상태로 보낼지 등을 결정.

> Q. CPU 스케줄링의 목적을 설명하시오.  
> A. - 공평성  - 효율성  - 안정성  - 확장성  - 반응 시간 보장  - 무한 연기 방지.

> Q. 선점형 스케줄링과 비선점형 스케줄링을 비교하여 설명하시오.  
> A. 선점형 스케줄링은 os가 필요하다고 판단하면 실행 상태에 있는 프로세스의 작업을 중단 시키고 새로우 작업을 시작할 수 있지만, 비선점형 스케줄링은 프로세스가 실행 상태에 cpu를 사용하고 있는 동안에는 건들 수 없다.

> Q. 선점형과 비선점형 스케줄링의 장단점은?  
> A.  
> 장점 :  
> 선점형 : 프로세스가 CPU를 독점할 수 없어 대화형이나 시분할 시스템에 적합하다.  
> 비선점형 : CPU 스케줄러의 작업량이 적고 문맥 교환의 오버헤드가 적다.  
> 단점 :  
> 선점형: 문맥 교환의 오버헤드가 많다.  
> 비선점형: 기다리는 프로세스가 많아 처리율이 떨어진다.

> Q. 프로세스의 우선 순위를 배정하는 방식에는 어떤 것이 있는가?  
> A. 고정 우선 순위 방식과 변동 우선 순위 방식.

> Q. FCFS, SJF, HRN 스케줄링의 특징을 설명하시오.  
> A.   
> FCFS : 메모리에 적재되는 순서로 CPU를 할당한다.  
> SJF : 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 방식  
> HRN : 대기 시간 및 실행 시간 고려 우선수위 조정.

> Q. 라운드 로빈, SRT, 다단계 큐, 다단계 피드백 큐 스케줄링의 특징을 설명하시오.  
> A.   
> 라운드 로빈 : 타임 슬라이스 기반, 공평한 CPU 배분  
> SRT : 남은 작업 시간 가장 적은 프로세스 우선  
> 다단계 큐 : 우선 순위별 큐 구분  
> 다단계 피드백 큐 : 프로세스 성능에 따라 큐 이동 가능.

> Q. 타임 슬라이스의 크기를 정하는 것과 시스템 효율성에 대해 설명하시오.  
> A.   
> 타임 슬라이스가 작으면 문맥 교환 빈번  
> 타임 슬라이스가 크면 처리량 감소 가능  
> 적절한 타임 슬라이스 설정으로 시스템 효율성 조정 필요.
